<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SMLMFrameConnection.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://JuliaSMLM.github.io/SMLMFrameConnection.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SMLMFrameConnection.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Input-Requirements"><span>Input Requirements</span></a></li><li><a class="tocitem" href="#Algorithm-Overview"><span>Algorithm Overview</span></a></li><li><a class="tocitem" href="#Outputs"><span>Outputs</span></a></li><li><a class="tocitem" href="#Parameters"><span>Parameters</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li><li><a class="tocitem" href="#Citation"><span>Citation</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SMLMFrameConnection"><a class="docs-heading-anchor" href="#SMLMFrameConnection">SMLMFrameConnection</a><a id="SMLMFrameConnection-1"></a><a class="docs-heading-anchor-permalink" href="#SMLMFrameConnection" title="Permalink"></a></h1><p>Frame-connection for 2D single molecule localization microscopy (SMLM) data: linking localizations from the same fluorophore blinking event across consecutive frames into single, higher-precision localizations. Uses spatiotemporal LAP assignment to optimally connect temporally adjacent detections based on spatial proximity and estimated blinking kinetics. See <a href="https://doi.org/10.3389/fbinf.2021.724325">Schodt &amp; Lidke 2021</a>.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;SMLMFrameConnection&quot;)</code></pre><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><pre><code class="language-julia hljs">using SMLMFrameConnection

# Run frame connection on your BasicSMLD with Emitter2DFit emitters
(combined, info) = frameconnect(smld)

# combined is the main output - higher precision localizations
# info contains track assignments and algorithm metadata</code></pre><h2 id="Input-Requirements"><a class="docs-heading-anchor" href="#Input-Requirements">Input Requirements</a><a id="Input-Requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Input-Requirements" title="Permalink"></a></h2><p>Input <code>BasicSMLD</code> must contain <code>Emitter2DFit</code> emitters with:</p><p><strong>Required:</strong></p><ul><li><code>x</code>, <code>y</code>: Position coordinates (microns)</li><li><code>σ_x</code>, <code>σ_y</code>: Position uncertainties (microns) - must be &gt; 0 for MLE weighting</li><li><code>frame</code>: Frame number (1-based)</li></ul><p><strong>Optional:</strong></p><ul><li><code>photons</code>, <code>bg</code>: Photometry (summed in output)</li><li><code>dataset</code>: Dataset identifier (default: 1)</li></ul><h2 id="Algorithm-Overview"><a class="docs-heading-anchor" href="#Algorithm-Overview">Algorithm Overview</a><a id="Algorithm-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Overview" title="Permalink"></a></h2><ol><li><strong>Preclustering</strong>: Groups spatially and temporally adjacent localizations into candidate clusters</li><li><strong>Parameter Estimation</strong>: Estimates fluorophore blinking kinetics (<code>k_on</code>, <code>k_off</code>, <code>k_bleach</code>) and emitter density from the data</li><li><strong>Frame Connection</strong>: Uses Linear Assignment Problem (LAP) to optimally assign localizations to emitters based on spatial proximity and estimated photophysics</li><li><strong>Combination</strong>: Combines connected localizations using MLE weighted mean for improved precision</li></ol><h2 id="Outputs"><a class="docs-heading-anchor" href="#Outputs">Outputs</a><a id="Outputs-1"></a><a class="docs-heading-anchor-permalink" href="#Outputs" title="Permalink"></a></h2><table><tr><th style="text-align: right">Output</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>combined</code></td><td style="text-align: right"><strong>Main output</strong> - combined high-precision localizations</td></tr><tr><td style="text-align: right"><code>info.connected</code></td><td style="text-align: right">Original localizations with <code>track_id</code> assigned</td></tr><tr><td style="text-align: right"><code>info.n_tracks</code></td><td style="text-align: right">Number of tracks formed</td></tr><tr><td style="text-align: right"><code>info.elapsed_s</code></td><td style="text-align: right">Wall time in seconds</td></tr></table><h2 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h2><pre><code class="language-julia hljs">frameconnect(smld;
    n_density_neighbors = 2,   # Clusters for density estimation
    max_sigma_dist = 5.0,        # Distance threshold multiplier
    max_frame_gap = 5,        # Max frame gap for connections
    max_neighbors = 2              # Nearest neighbors for preclustering
)</code></pre><ul><li><code>max_sigma_dist</code>: Higher values allow connections over larger distances</li><li><code>max_frame_gap</code>: Increase for dyes with long dark states (dSTORM: 10-20)</li></ul><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><ul><li><a href="#SMLMFrameConnection.CalibrationConfig"><code>SMLMFrameConnection.CalibrationConfig</code></a></li><li><a href="#SMLMFrameConnection.CalibrationResult"><code>SMLMFrameConnection.CalibrationResult</code></a></li><li><a href="#SMLMFrameConnection.FrameConnectConfig"><code>SMLMFrameConnection.FrameConnectConfig</code></a></li><li><a href="#SMLMFrameConnection.FrameConnectInfo"><code>SMLMFrameConnection.FrameConnectInfo</code></a></li><li><a href="#SMLMFrameConnection.ParamStruct"><code>SMLMFrameConnection.ParamStruct</code></a></li><li><a href="#SMLMFrameConnection.analyze_calibration-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, CalibrationConfig}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.analyze_calibration</code></a></li><li><a href="#SMLMFrameConnection.apply_calibration-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, CalibrationResult}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.apply_calibration</code></a></li><li><a href="#SMLMFrameConnection.combinelocalizations-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.combinelocalizations</code></a></li><li><a href="#SMLMFrameConnection.compress_connectID-Tuple{Vector{Int64}}"><code>SMLMFrameConnection.compress_connectID</code></a></li><li><a href="#SMLMFrameConnection.compress_connectID!-Tuple{Vector{Int64}}"><code>SMLMFrameConnection.compress_connectID!</code></a></li><li><a href="#SMLMFrameConnection.computeclusterinfo-Tuple{Vector{Matrix{Float32}}}"><code>SMLMFrameConnection.computeclusterinfo</code></a></li><li><a href="#SMLMFrameConnection.connect1DS-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, Int64, Vector{Int64}, Int64}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.connect1DS</code></a></li><li><a href="#SMLMFrameConnection.connectlocalizations-Tuple{Vector{Int64}, Vector{Matrix{Float32}}, ParamStruct, Int64}"><code>SMLMFrameConnection.connectlocalizations</code></a></li><li><a href="#SMLMFrameConnection.connectlocalizations!-Tuple{Vector{Int64}, Vector{Matrix{Float32}}, ParamStruct, Int64}"><code>SMLMFrameConnection.connectlocalizations!</code></a></li><li><a href="#SMLMFrameConnection.create_costmatrix-Tuple{Vector{Matrix{Float32}}, ParamStruct, Int64, Int64, Vector{Float64}}"><code>SMLMFrameConnection.create_costmatrix</code></a></li><li><a href="#SMLMFrameConnection.defineidealFC-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.defineidealFC</code></a></li><li><a href="#SMLMFrameConnection.estimatedensities-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, Vector{Matrix{Float32}}, ParamStruct}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.estimatedensities</code></a></li><li><a href="#SMLMFrameConnection.estimateparams-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, Vector{Matrix{Float32}}}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.estimateparams</code></a></li><li><a href="#SMLMFrameConnection.frameconnect-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.frameconnect</code></a></li><li><a href="#SMLMFrameConnection.linkclusters-Tuple{Vector{Int64}, Int64, Union{Int64, Vector{Int64}}, Vector{Int64}}"><code>SMLMFrameConnection.linkclusters</code></a></li><li><a href="#SMLMFrameConnection.linkclusters!-Tuple{Vector{Int64}, Int64, Union{Int64, Vector{Int64}}, Vector{Int64}}"><code>SMLMFrameConnection.linkclusters!</code></a></li><li><a href="#SMLMFrameConnection.organizeclusters-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.organizeclusters</code></a></li><li><a href="#SMLMFrameConnection.precluster-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, ParamStruct}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.precluster</code></a></li><li><a href="#SMLMFrameConnection.solveLAP-Tuple{Matrix{Float32}}"><code>SMLMFrameConnection.solveLAP</code></a></li><li><a href="#SMLMFrameConnection.to_emitter2dfit-Tuple{SMLMData.AbstractEmitter, Int64}"><code>SMLMFrameConnection.to_emitter2dfit</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.CalibrationConfig" href="#SMLMFrameConnection.CalibrationConfig"><code>SMLMFrameConnection.CalibrationConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CalibrationConfig</code></pre><p>Configuration for optional uncertainty calibration within frame connection.</p><p>Calibration analyzes frame-to-frame jitter within connected tracks to estimate a motion variance (<code>σ_motion²</code>) and CRLB scale factor (<code>k²</code>), then applies corrected uncertainties before track combination: <code>Σ_corrected = σ_motion² I + k² Σ_CRLB</code>.</p><p><strong>Fields</strong></p><ul><li><code>clamp_k_to_one::Bool=true</code>: Clamp k_scale to minimum of 1.0 (CRLB is a lower bound)</li><li><code>filter_high_chi2::Bool=false</code>: Filter tracks with high chi² pairs before fitting</li><li><code>chi2_filter_threshold::Float64=6.0</code>: Chi² threshold for track filtering (per pair)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/structdefinitions.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.CalibrationResult" href="#SMLMFrameConnection.CalibrationResult"><code>SMLMFrameConnection.CalibrationResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CalibrationResult</code></pre><p>Output diagnostics from uncertainty calibration. Returned in <code>FrameConnectInfo.calibration</code> when calibration is enabled.</p><p>The calibration model fits: <code>observed_var = A + B * CRLB_var</code> where <code>A = σ_motion²</code> (additive motion/vibration variance) and <code>B = k²</code> (CRLB scale factor).</p><p><strong>Fields</strong></p><ul><li><code>sigma_motion_nm::Float64</code>: Estimated motion std dev in nm (√A × 1000)</li><li><code>k_scale::Float64</code>: CRLB scale factor (√B, or clamped √B if clamp<em>k</em>to_one)</li><li><code>A::Float64</code>: Fit intercept (σ_motion² in μm²)</li><li><code>B::Float64</code>: Fit slope (k²)</li><li><code>A_sigma::Float64</code>: Standard error of A</li><li><code>B_sigma::Float64</code>: Standard error of B</li><li><code>r_squared::Float64</code>: R² of the WLS fit</li><li><code>mean_chi2::Float64</code>: Mean chi² across all frame-to-frame pairs</li><li><code>n_pairs::Int</code>: Number of frame-to-frame pairs used in fit</li><li><code>n_tracks_used::Int</code>: Number of tracks contributing pairs</li><li><code>n_tracks_filtered::Int</code>: Number of tracks removed by chi² filter</li><li><code>bin_centers::Vector{Float64}</code>: Bin centers (CRLB variance) for diagnostic plots</li><li><code>bin_observed::Vector{Float64}</code>: Bin observed variance for diagnostic plots</li><li><code>frame_shifts::Dict{Int, Vector{NTuple{2,Float64}}}</code>: Per-dataset (dx,dy) shifts for jitter plots</li><li><code>calibration_applied::Bool</code>: Whether calibration was actually applied (false on fallback)</li><li><code>warning::String</code>: Warning message if calibration fell back (empty if OK)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/structdefinitions.jl#L23-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.FrameConnectConfig" href="#SMLMFrameConnection.FrameConnectConfig"><code>SMLMFrameConnection.FrameConnectConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FrameConnectConfig</code></pre><p>Configuration parameters for frame connection algorithm.</p><p><strong>Fields</strong></p><ul><li><code>n_density_neighbors::Int=2</code>: Number of nearest preclusters used for local density                            estimates (see <code>estimatedensities</code>)</li><li><code>max_sigma_dist::Float64=5.0</code>: Multiplier of localization errors that defines a                           pre-clustering distance threshold (see <code>precluster</code>)</li><li><code>max_frame_gap::Int=5</code>: Maximum frame gap between temporally adjacent localizations                       in a precluster (see <code>precluster</code>)</li><li><code>max_neighbors::Int=2</code>: Maximum number of nearest-neighbors inspected for precluster                  membership (see <code>precluster</code>)</li><li><code>calibration::Union{CalibrationConfig, Nothing}=nothing</code>: Optional uncertainty calibration</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Without calibration (default)
(combined, info) = frameconnect(smld)

# With calibration
config = FrameConnectConfig(calibration=CalibrationConfig())
(combined, info) = frameconnect(smld, config)

# With calibration + chi2 filtering
config = FrameConnectConfig(
    calibration=CalibrationConfig(filter_high_chi2=true, chi2_filter_threshold=4.0)
)
(combined, info) = frameconnect(smld, config)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/structdefinitions.jl#L69-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.FrameConnectInfo" href="#SMLMFrameConnection.FrameConnectInfo"><code>SMLMFrameConnection.FrameConnectInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FrameConnectInfo{T}</code></pre><p>Secondary output from <code>frameconnect()</code> containing track assignments and algorithm metadata.</p><p><strong>Fields</strong></p><ul><li><code>connected::BasicSMLD{T}</code>: Input SMLD with track_id assigned (localizations uncombined)</li><li><code>n_input::Int</code>: Number of input localizations</li><li><code>n_tracks::Int</code>: Number of tracks formed</li><li><code>n_combined::Int</code>: Number of output localizations</li><li><code>k_on::Float64</code>: Estimated on rate (1/frame)</li><li><code>k_off::Float64</code>: Estimated off rate (1/frame)</li><li><code>k_bleach::Float64</code>: Estimated bleach rate (1/frame)</li><li><code>p_miss::Float64</code>: Probability of missed detection</li><li><code>initial_density::Vector{Float64}</code>: Initial density estimate per cluster (emitters/μm²)</li><li><code>elapsed_s::Float64</code>: Wall time in seconds</li><li><code>algorithm::Symbol</code>: Algorithm used (<code>:lap</code>)</li><li><code>n_preclusters::Int</code>: Number of preclusters formed</li><li><code>calibration::Union{CalibrationResult, Nothing}</code>: Calibration diagnostics (nothing if disabled)</li></ul><p><strong>Rate Parameter Interpretation</strong></p><p>The rate parameters describe the photophysics of blinking fluorophores:</p><ul><li><code>k_on</code>: Rate at which dark emitters convert to visible state</li><li><code>k_off</code>: Rate at which visible emitters convert to reversible dark state</li><li><code>k_bleach</code>: Rate at which visible emitters are irreversibly photobleached</li><li>Duty cycle = k<em>on / (k</em>on + k_off)</li><li>For typical dSTORM: k<em>on &lt;&lt; k</em>off (low duty cycle, mostly dark with brief blinks)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">(combined, info) = frameconnect(smld)
println(&quot;Connected $(info.n_input) → $(info.n_combined) localizations&quot;)
println(&quot;Formed $(info.n_tracks) tracks in $(info.elapsed_s)s&quot;)
# Access track assignments via info.connected
# Check calibration results if enabled
if info.calibration !== nothing
    println(&quot;k_scale = $(info.calibration.k_scale)&quot;)
    println(&quot;σ_motion = $(info.calibration.sigma_motion_nm) nm&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/connectinfo.jl#L3-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.ParamStruct" href="#SMLMFrameConnection.ParamStruct"><code>SMLMFrameConnection.ParamStruct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParamStruct(initial_density::Vector{Float64},
    k_on::Float64, k_off::Float64, k_bleach::Float64, p_miss::Float64,
    max_sigma_dist::Float64, max_frame_gap::Int, n_density_neighbors::Int)</code></pre><p>Structure of parameters needed for frame-connection.</p><p><strong>Fields</strong></p><ul><li><code>initial_density</code>: Density of emitters at the start of the experiment.                   (see estimatedensities()) (emitters/μm²)</li><li><code>n_density_neighbors</code>: Number of nearest preclusters used for local density                      estimates. (default = 2)(see estimatedensities())</li><li><code>k_on</code>: Rate at which dark emitters convert to the visible state (1/frame).</li><li><code>k_off</code>: Rate at which visible emitters convert to the reversible dark state (1/frame).</li><li><code>k_bleach</code>: Rate at which visible emitters are irreversibly photobleached (1/frame).</li><li><code>p_miss</code>: Probability of missing a localization of a visible emitter.</li><li><code>max_sigma_dist</code>: Multiplier of localization errors that defines a pre-clustering              distance threshold. (default = 5)(see precluster())(unitless)</li><li><code>max_frame_gap</code>: Maximum frame gap between temporally adjacent localizations in                a precluster. (default = 5)(see precluster())(frames)</li><li><code>max_neighbors</code>: Maximum number of nearest-neighbors inspected for precluster           membership.  Ideally, this would be set to inf, but that&#39;s not           feasible for most data. (default = 2)(see precluster())</li></ul><p>Note: k<em>on, k</em>off, and k<em>bleach are transition rates, not duty cycle fractions. The duty cycle (fraction of time in ON state) is k</em>on/(k<em>on + k</em>off). For typical dSTORM, k<em>on &lt;&lt; k</em>off gives low duty cycle (mostly dark, brief blinks).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/structdefinitions.jl#L109-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.analyze_calibration-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, CalibrationConfig}} where {T, E&lt;:SMLMData.AbstractEmitter}" href="#SMLMFrameConnection.analyze_calibration-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, CalibrationConfig}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.analyze_calibration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">analyze_calibration(smld::BasicSMLD, config::CalibrationConfig) -&gt; CalibrationResult</code></pre><p>Analyze frame-to-frame jitter in connected tracks to estimate uncertainty calibration parameters.</p><p>Collects consecutive-frame pairs within each track, computes observed positional variance vs CRLB variance, and fits the model: <code>observed_var = A + B * CRLB_var</code> using weighted least squares on binned data.</p><p>Falls back gracefully (returns <code>calibration_applied=false</code>) if fewer than 100 frame-to-frame pairs are available or if the fit quality is poor (R² &lt; 0.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/calibration.jl#L7-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.apply_calibration-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, CalibrationResult}} where {T, E&lt;:SMLMData.AbstractEmitter}" href="#SMLMFrameConnection.apply_calibration-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, CalibrationResult}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.apply_calibration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_calibration(smld::BasicSMLD, result::CalibrationResult) -&gt; BasicSMLD</code></pre><p>Apply calibrated uncertainties to emitters. Returns a new SMLD with corrected covariance: <code>Σ_corrected = σ_motion² I + k² Σ_CRLB</code>.</p><p>Only modifies σ<em>x, σ</em>y, σ_xy. Positions and other fields are unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/calibration.jl#L262-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.combinelocalizations-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}} where {T, E&lt;:SMLMData.AbstractEmitter}" href="#SMLMFrameConnection.combinelocalizations-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.combinelocalizations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smld_combined = combinelocalizations(smld::BasicSMLD{T,E}) where {T, E&lt;:SMLMData.AbstractEmitter}</code></pre><p>Combine clustered localizations in <code>smld</code> into higher precision localizations.</p><p><strong>Description</strong></p><p>This function combines localizations in <code>smld</code> that share the same value of track_id.  Localizations are combined assuming they arose from independent measurements of the same position with Gaussian errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/combinelocalizations.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.compress_connectID!-Tuple{Vector{Int64}}" href="#SMLMFrameConnection.compress_connectID!-Tuple{Vector{Int64}}"><code>SMLMFrameConnection.compress_connectID!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compress_connectID!(connectID::Vector{Int32})</code></pre><p>Make <code>connectID</code> consists of the set of integers <code>1:length(unique(connectID))</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/compress_connectID.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.compress_connectID-Tuple{Vector{Int64}}" href="#SMLMFrameConnection.compress_connectID-Tuple{Vector{Int64}}"><code>SMLMFrameConnection.compress_connectID</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connectID = compress_connectID(connectID::Vector{Int32})</code></pre><p>Make <code>connectID</code> consists of the set of integers <code>1:length(unique(connectID))</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/compress_connectID.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.computeclusterinfo-Tuple{Vector{Matrix{Float32}}}" href="#SMLMFrameConnection.computeclusterinfo-Tuple{Vector{Matrix{Float32}}}"><code>SMLMFrameConnection.computeclusterinfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clusterdurations, nobservations = 
    computeclusterinfo(clusterdata::Vector{Matrix{Float32}})</code></pre><p>Compute the durations of and number of member localizations in clusters.</p><p><strong>Description</strong></p><p>This method computes the duration of each cluster and the number of localizations in each cluster present in the input <code>clusterdata</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/computeclusterinfo.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.connect1DS-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, Int64, Vector{Int64}, Int64}} where {T, E&lt;:SMLMData.AbstractEmitter}" href="#SMLMFrameConnection.connect1DS-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, Int64, Vector{Int64}, Int64}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.connect1DS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connect1DS(smld::BasicSMLD{T,E}, dataset::Int,
           connectID::Vector{Int}, maxID::Int;
           max_frame_gap::Int = 5) where {T, E&lt;:SMLMData.AbstractEmitter}</code></pre><p>Define the &quot;ideal&quot; frame-connection result for simulated <code>smld</code> with one dataset.</p><p><strong>Description</strong></p><p>This is a helper function which defines the ideal FC result for a single dataset.  The user should probably not bother using this, and instead should call defineidealFC().</p><p><strong>Inputs</strong></p><ul><li><code>smld</code>: BasicSMLD with track_id populated to indicate emitter ID.</li><li><code>dataset</code>: Dataset number to be connected.</li><li><code>connectID</code>: Current connection IDs for all emitters.</li><li><code>maxID</code>: Current maximum ID value.</li><li><code>max_frame_gap</code>: Maximum frame gap allowed between localizations connected in                the &quot;ideal&quot; result.</li></ul><p><strong>Returns</strong></p><ul><li>Updated connectID array and new maxID.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/defineidealFC.jl#L3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.connectlocalizations!-Tuple{Vector{Int64}, Vector{Matrix{Float32}}, ParamStruct, Int64}" href="#SMLMFrameConnection.connectlocalizations!-Tuple{Vector{Int64}, Vector{Matrix{Float32}}, ParamStruct, Int64}"><code>SMLMFrameConnection.connectlocalizations!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connectlocalizations!(connectID::Vector{Int64},
    clusterdata::Vector{Matrix{Float32}},
    params::ParamStruct, nframes::Int64)</code></pre><p>Connect localizations in <code>clusterdata</code> by solving a linear assignment problem.</p><p><strong>Description</strong></p><p>Connect localizations in <code>clusterdata</code> by giving &quot;connected&quot; localizations the same integer value for their field <code>smd.connectID</code>.  Associations are made by solving a linear assignment problem which designates the ideal connections between localizations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/connectlocalizations.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.connectlocalizations-Tuple{Vector{Int64}, Vector{Matrix{Float32}}, ParamStruct, Int64}" href="#SMLMFrameConnection.connectlocalizations-Tuple{Vector{Int64}, Vector{Matrix{Float32}}, ParamStruct, Int64}"><code>SMLMFrameConnection.connectlocalizations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connectID = connectlocalizations(connectID::Vector{Int64}, 
    clusterdata::Vector{Matrix{Float32}}, 
    params::ParamStruct, nframes::Int64)</code></pre><p>Connect localizations in <code>clusterdata</code> by solving a linear assignment problem.</p><p><strong>Description</strong></p><p>Connect localizations in <code>clusterdata</code> by giving &quot;connected&quot; localizations the same integer value for their field <code>smd.connectID</code>.  Associations are made by solving a linear assignment problem which designates the ideal connections between localizations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/connectlocalizations.jl#L54-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.create_costmatrix-Tuple{Vector{Matrix{Float32}}, ParamStruct, Int64, Int64, Vector{Float64}}" href="#SMLMFrameConnection.create_costmatrix-Tuple{Vector{Matrix{Float32}}, ParamStruct, Int64, Int64, Vector{Float64}}"><code>SMLMFrameConnection.create_costmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">costmatrix = create_costmatrix(clusterdata::Vector{Matrix{Float32}},
    params::ParamStruct, clusterind::Int64, nframes::Int64,
    base_rho_on::Vector{Float64})</code></pre><p>Create a cost matrix for connections between localizations in <code>clusterdata</code>.</p><p><strong>Description</strong></p><p>The costs associated with connecting/not connecting the localizations in the input set of data in <code>clusterdata</code> are placed in entries of the output matrix <code>costmatrix</code>.  For N localizations in <code>clusterdata</code>, the output <code>costmatrix</code> will be an 2Nx2N block matrix.  The NxN blocks are attributed the following meanings: the upper-left &quot;connection&quot; block corresponds to adding localizations to existing clusters of other localizations, the bottom-left &quot;birth&quot; block corresponds to introduction of a new cluster, and the upper-right &quot;death&quot; block corresponds to preventing admission of any more localizations to a cluster. The bottom-right &quot;auxillary&quot; block is the transpose of the &quot;connection&quot; block. Forbidden connections are indicated by <code>missing</code>.</p><p><code>base_rho_on</code> is a precomputed unit-density on-state density curve of length <code>nframes</code>, shared across all clusters to avoid per-cluster allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/create_costmatrix.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.defineidealFC-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}} where {T, E&lt;:SMLMData.AbstractEmitter}" href="#SMLMFrameConnection.defineidealFC-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.defineidealFC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smld_connected, smld_combined = defineidealFC(
    smld::BasicSMLD{T,E};
    max_frame_gap::Int = 5) where {T, E&lt;:SMLMData.AbstractEmitter}</code></pre><p>Define the &quot;ideal&quot; frame-connection result for a simulated <code>smld</code>.</p><p><strong>Description</strong></p><p>This function defines the &quot;ideal&quot; frame connection result from a simulation. That is to say, for a simulated BasicSMLD structure <code>smld</code> with <code>track_id</code> field populated to indicate emitter membership of localizations, this function will generate an &quot;ideal&quot; FC result which combines all blinking events that appeared with frame gaps less than <code>max_frame_gap</code> of one another.  Note that for very high duty cycles, multiple blinking events might be mistakingly combined by this method (i.e., if the emitter blinks back on within <code>max_frame_gap</code> frames of its previous blink).  Note that localizations are not allowed to be connected across datasets.</p><p><strong>Inputs</strong></p><ul><li><code>smld</code>: BasicSMLD with track_id populated to indicate emitter ID.</li><li><code>max_frame_gap</code>: Maximum frame gap allowed between localizations connected in                the &quot;ideal&quot; result.</li></ul><p><strong>Outputs</strong></p><ul><li><code>smld_connected</code>: Copy of the input <code>smld</code> with track_id modified to reflect                   blinking event ID.</li><li><code>smld_combined</code>: Ideal frame-connection result with localizations combined.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/defineidealFC.jl#L85-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.estimatedensities-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, Vector{Matrix{Float32}}, ParamStruct}} where {T, E&lt;:SMLMData.AbstractEmitter}" href="#SMLMFrameConnection.estimatedensities-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, Vector{Matrix{Float32}}, ParamStruct}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.estimatedensities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_density = estimatedensities(smld::BasicSMLD{T,E},
    clusterdata::Vector{Matrix{Float32}}, params::ParamStruct) where {T, E&lt;:SMLMData.AbstractEmitter}</code></pre><p>Estimate local emitter densities for clusters in <code>smld</code> and <code>clusterdata</code>.</p><p><strong>Description</strong></p><p>The initial local densities <code>initial_density</code> around each pre-cluster present in <code>smld</code>/<code>clusterdata</code> are estimated based on the local density of pre-clusters throughout the entire set of data as well as some of the rate parameters provided in <code>params</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/estimatedensities.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.estimateparams-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, Vector{Matrix{Float32}}}} where {T, E&lt;:SMLMData.AbstractEmitter}" href="#SMLMFrameConnection.estimateparams-Union{Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, Vector{Matrix{Float32}}}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.estimateparams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_on, k_off, k_bleach, p_miss, nemitters =
    estimateparams(smld::BasicSMLD{T,E},
                   clusterdata::Vector{Matrix{Float32}}) where {T, E&lt;:SMLMData.AbstractEmitter}</code></pre><p>Estimate rate parameters from the clusters in <code>smld</code> and <code>clusterdata</code>.</p><p><strong>Description</strong></p><p>The rate parameters <code>k_on</code>, <code>k_off</code>, and <code>k_bleach</code>, the probability of missing a localization for a visible emitter <code>p_miss</code>, and the underlying number of emitters <code>nemitters</code> are estimated from the pre-clusters in <code>smld</code>/<code>clusterdata</code>.  This is done by assuming that pre-clusters are, on average, representative of a single blinking event of a single emitter.</p><p><strong>Citation</strong></p><p>Schodt David J., Lidke Keith A., &quot;Spatiotemporal Clustering of Repeated Super-Resolution Localizations via Linear Assignment Problem&quot;, Front. Bioinform., 20 October 2021 https://doi.org/10.3389/fbinf.2021.724325</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/estimateparams.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.frameconnect-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}} where {T, E&lt;:SMLMData.AbstractEmitter}" href="#SMLMFrameConnection.frameconnect-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.frameconnect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(combined, info) = frameconnect(smld::BasicSMLD, config::FrameConnectConfig)
(combined, info) = frameconnect(smld::BasicSMLD; kwargs...)</code></pre><p>Connect repeated localizations of the same emitter in <code>smld</code>.</p><p><strong>Description</strong></p><p>Repeated localizations of the same emitter present in <code>smld</code> are connected and combined into higher precision localizations of that emitter. This is done by</p><ol><li>forming pre-clusters of localizations, 2) estimating rate parameters from</li></ol><p>the pre-clusters, 3) solving a linear assignment problem for connecting localizations in each pre-cluster, and 4) combining the connected localizations using their MLE position estimate assuming Gaussian noise.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: Localizations to connect. Must contain emitters with valid                    position uncertainties (σ<em>x, σ</em>y).</li><li><code>config::FrameConnectConfig</code>: Configuration parameters (optional, can use kwargs instead)</li></ul><p><strong>Keyword Arguments (equivalent to FrameConnectConfig fields)</strong></p><ul><li><code>n_density_neighbors::Int=2</code>: Number of nearest preclusters used for local density                            estimates (see <code>estimatedensities</code>)</li><li><code>max_sigma_dist::Float64=5.0</code>: Multiplier of localization errors that defines a                           pre-clustering distance threshold (see <code>precluster</code>)</li><li><code>max_frame_gap::Int=5</code>: Maximum frame gap between temporally adjacent localizations                       in a precluster (see <code>precluster</code>)</li><li><code>max_neighbors::Int=2</code>: Maximum number of nearest-neighbors inspected for precluster                  membership (see <code>precluster</code>)</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(combined, info)</code>:</p><ul><li><code>combined::BasicSMLD</code>: Connected localizations combined into higher precision results</li><li><code>info::FrameConnectInfo</code>: Track assignments and algorithm metadata (see <a href="#SMLMFrameConnection.FrameConnectInfo"><code>FrameConnectInfo</code></a>)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Using kwargs (most common)
(combined, info) = frameconnect(smld)
(combined, info) = frameconnect(smld; max_frame_gap=10)

# Using config struct
config = FrameConnectConfig(max_frame_gap=10, max_sigma_dist=3.0)
(combined, info) = frameconnect(smld, config)

println(&quot;Connected $(info.n_input) → $(info.n_combined) localizations&quot;)
println(&quot;Formed $(info.n_tracks) tracks from $(info.n_preclusters) preclusters&quot;)

# Access track assignments for downstream analysis
track_ids = [e.track_id for e in info.connected.emitters]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/frameconnect.jl#L3-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.linkclusters!-Tuple{Vector{Int64}, Int64, Union{Int64, Vector{Int64}}, Vector{Int64}}" href="#SMLMFrameConnection.linkclusters!-Tuple{Vector{Int64}, Int64, Union{Int64, Vector{Int64}}, Vector{Int64}}"><code>SMLMFrameConnection.linkclusters!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connectID, maxconnectID = linkclusters!(connectID::Int64, 
    maxconnectID::Int64, updateind::Vector{Int64}, 
    assignment::Vector{Int64})</code></pre><p>Force localizations linked by <code>assignment</code> to share same the same <code>connectID</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/linkclusters.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.linkclusters-Tuple{Vector{Int64}, Int64, Union{Int64, Vector{Int64}}, Vector{Int64}}" href="#SMLMFrameConnection.linkclusters-Tuple{Vector{Int64}, Int64, Union{Int64, Vector{Int64}}, Vector{Int64}}"><code>SMLMFrameConnection.linkclusters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connectID, maxconnectID = linkclusters(
    connectID::Int64, maxconnectID::Int64, 
    updateind::Vector{Int64}, assignment::Vector{Int64})</code></pre><p>Force localizations linked by <code>assignment</code> to share same the same <code>connectID</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/linkclusters.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.organizeclusters-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}} where {T, E&lt;:SMLMData.AbstractEmitter}" href="#SMLMFrameConnection.organizeclusters-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.organizeclusters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clusterdata = organizeclusters(smld::BasicSMLD{T,E}) where {T, E&lt;:SMLMData.AbstractEmitter}</code></pre><p>Organize pre-clusters into a vector indexing distinct clusters.</p><p><strong>Description</strong></p><p>Pre-clusters in the input <code>smld</code>, as related by their shared integer value of <code>track_id</code>, are organized into a vector of matrices <code>clusterdata</code>.  Each index of <code>clusterdata</code> corresponds to a distinct cluster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/organizeclusters.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.precluster-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, ParamStruct}} where {T, E&lt;:SMLMData.AbstractEmitter}" href="#SMLMFrameConnection.precluster-Union{Tuple{SMLMData.BasicSMLD{T, E}}, Tuple{E}, Tuple{T}, Tuple{SMLMData.BasicSMLD{T, E}, ParamStruct}} where {T, E&lt;:SMLMData.AbstractEmitter}"><code>SMLMFrameConnection.precluster</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smld_preclustered = precluster(smld::BasicSMLD{T,E},
    params::ParamStruct = ParamStruct()) where {T, E&lt;:SMLMData.AbstractEmitter}</code></pre><p>Cluster localizations in <code>smld</code> based on distance and time thresholds in <code>params</code>.</p><p><strong>Description</strong></p><p>Localizations in the input structure <code>smld</code> are clustered together based on their spatiotemporal separations.  All localizations within a spatial threshold of <code>params.max_sigma_dist*mean([σ_x σ_y])</code> and a temporal threshold of <code>params.max_frame_gap</code> of one another will be clustered together, meaning that these localizations now share the same unique integer value for their track_id field.</p><p><strong>Notes</strong></p><p>Pre-clustering allows localizations observed in the same frame to be in the same cluster.  This is done to prevent exclusion of the &quot;correct&quot; localization from its ideal cluster due to a previously included &quot;incorrect&quot; localization into that cluster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/precluster.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.solveLAP-Tuple{Matrix{Float32}}" href="#SMLMFrameConnection.solveLAP-Tuple{Matrix{Float32}}"><code>SMLMFrameConnection.solveLAP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assignment, cost = solveLAP(costmatrix::Matrix{Float32})</code></pre><p>Solve the linear assignment problem designated by <code>costmatrix</code>.</p><p><strong>Description</strong></p><p>Solve the linear assignment problem (LAP) defined by <code>costmatrix</code> using the package Hungarian.jl.  For now, this method is just a wrapper around  Hungarian.jl, however the intention is to add more checks and options to this method in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/solveLAP.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SMLMFrameConnection.to_emitter2dfit-Tuple{SMLMData.AbstractEmitter, Int64}" href="#SMLMFrameConnection.to_emitter2dfit-Tuple{SMLMData.AbstractEmitter, Int64}"><code>SMLMFrameConnection.to_emitter2dfit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_emitter2dfit(e::AbstractEmitter, track_id::Int) -&gt; Emitter2DFit</code></pre><p>Convert any AbstractEmitter to Emitter2DFit with specified track_id. Used internally to support different input emitter types while producing consistent Emitter2DFit output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMFrameConnection.jl/blob/1a17823a549322df0c63868097cf94f9d5095144/src/structdefinitions.jl#L150-L156">source</a></section></article><h2 id="Citation"><a class="docs-heading-anchor" href="#Citation">Citation</a><a id="Citation-1"></a><a class="docs-heading-anchor-permalink" href="#Citation" title="Permalink"></a></h2><p>David J. Schodt and Keith A. Lidke, &quot;Spatiotemporal Clustering of Repeated Super-Resolution Localizations via Linear Assignment Problem&quot;, Frontiers in Bioinformatics, 2021. <a href="https://doi.org/10.3389/fbinf.2021.724325">DOI: 10.3389/fbinf.2021.724325</a></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 14 February 2026 16:40">Saturday 14 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
